{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IERC1155 /* is ERC165 */ {\n    /**\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\n        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\n        The `_id` argument MUST be the token type being transferred.\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).        \n    */\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n\n    /**\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).      \n        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\n        The `_ids` argument MUST be the list of tokens being transferred.\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).                \n    */\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\n\n    /**\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled).        \n    */\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /**\n        @dev MUST emit when the URI is updated for a token ID.\n        URIs are defined in RFC 3986.\n        The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\n    */\n    event URI(string _value, uint256 indexed _id);\n\n    /**\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n        MUST revert on any other error.\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).        \n        @param _from    Source address\n        @param _to      Target address\n        @param _id      ID of the token type\n        @param _value   Transfer amount\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n    */\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\n\n    /**\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if length of `_ids` is not the same as length of `_values`.\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n        MUST revert on any other error.        \n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).                      \n        @param _from    Source address\n        @param _to      Target address\n        @param _ids     IDs of each token type (order and length must match _values array)\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\n    */\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n\n    /**\n        @notice Get the balance of an account's tokens.\n        @param _owner  The address of the token holder\n        @param _id     ID of the token\n        @return        The _owner's balance of the token type requested\n     */\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    /**\n        @notice Get the balance of multiple account/token pairs\n        @param _owners The addresses of the token holders\n        @param _ids    ID of the tokens\n        @return        The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\n     */\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n    /**\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n        @dev MUST emit the ApprovalForAll event on success.\n        @param _operator  Address to add to the set of authorized operators\n        @param _approved  True if the operator is approved, false to revoke approval\n    */\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /**\n        @notice Queries the approval status of an operator for a given owner.\n        @param _owner     The owner of the tokens\n        @param _operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "contracts/YieldBox.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// The YieldBox\n// The original BentoBox is owned by the Sushi team to set strategies for each token. Abracadabra wanted different strategies, which led to\n// them launching their own DegenBox. The YieldBox solves this by allowing an unlimited number of strategies for each token in a fully\n// permissionless manner. The YieldBox has no owner and operates fully permissionless.\n\n// Other improvements:\n// Better system to make sure the token to share ratio doesn't reset.\n// Full support for rebasing tokens.\n\n// This contract stores funds, handles their transfers, approvals and strategies.\n\n// Copyright (c) 2021, 2022 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"./interfaces/IWETH.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IERC1155.sol\";\nimport \"./interfaces/IERC1155TokenReceiver.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/Base64.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringFactory.sol\";\n\n// An asset is a token + a strategy\nstruct Asset {\n    uint96 standard;\n    address contractAddress;\n    IStrategy strategy;\n    uint256 tokenId;\n}\n\n/// @title YieldBox\n/// @author BoringCrypto, Keno\n/// @notice The YieldBox is a vault for tokens. The stored tokens can assigned to strategies.\n/// Yield from this will go to the token depositors.\n/// Any funds transfered directly onto the YieldBox will be lost, use the deposit function instead.\ncontract YieldBox is Domain, BoringBatchable, BoringFactory, IERC1155TokenReceiver {\n    using BoringMath for uint256;\n    using BoringAddress for address;\n    using BoringERC20 for IERC20;\n    using Base64 for bytes;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n\n    // TODO: Add events\n\n    // EIP-1155 events\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n    event URI(string _value, uint256 indexed _id);\n\n    // ******************************** //\n    // *** CONSTANTS AND IMMUTABLES *** //\n    // ******************************** //\n\n    IERC20 private immutable wethToken;\n\n    uint96 private constant EIP20 = 0;\n    uint96 private constant EIP721 = 1;\n    uint96 private constant EIP1155 = 2;\n\n    // ***************** //\n    // *** VARIABLES *** //\n    // ***************** //\n\n    // ids start at 1 so that id 0 means it's not yet registered\n    mapping(uint96 => mapping(address => mapping(IStrategy => mapping(uint256 => uint256)))) public ids;\n    Asset[] public assets;\n\n    // Balance per asset per address/contract in shares\n    mapping(uint256 => mapping(address => uint256)) public shares;\n\n    // Total shares per asset\n    mapping(uint256 => uint256) public totalShares;\n\n    // Approved operators per user. If the operator is a master contract, it will also approve all clones.\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    // ******************* //\n    // *** CONSTRUCTOR *** //\n    // ******************* //\n\n    constructor(IERC20 wethToken_) public {\n        wethToken = wethToken_;\n        assets.push(Asset(EIP20, address(0), IStrategy(0), 0));\n    }\n\n    // ***************** //\n    // *** MODIFIERS *** //\n    // ***************** //\n\n    /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address.\n    /// If 'from' is msg.sender, it's allowed.\n    /// If 'msg.sender' is an address (an operator) that is approved by 'from', it's allowed.\n    /// If 'msg.sender' is a clone of a masterContract that is approved by 'from', it's allowed.\n    modifier allowed(address from) {\n        if (from != msg.sender && !isApprovedForAll[from][msg.sender]) {\n            address masterContract = masterContractOf[msg.sender];\n            require(masterContract != address(0) && isApprovedForAll[masterContract][from], \"YieldBox: Not approved\");\n        }\n        _;\n    }\n\n    // ************************** //\n    // *** INTERNAL FUNCTIONS *** //\n    // ************************** //\n\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function _toShares(\n        uint256 totalShares_,\n        uint256 totalAmount,\n        uint256 amount,\n        bool roundUp\n    ) internal pure returns (uint256 share) {\n        // To prevent reseting the ratio due to withdrawal of all shares, we start with\n        // 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which\n        // functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy\n        // due to 'gifting' or rebasing tokens. (Up to a certain degree)\n        totalAmount = totalAmount.add(1);\n        totalShares_ = totalShares_.add(1e8);\n\n        // Calculte the shares using te current amount to share ratio\n        share = amount.mul(totalShares_) / totalAmount;\n\n        // Default is to round down (Solidity), round up if required\n        if (roundUp && share.mul(totalAmount) / totalShares_ < amount) {\n            share = share.add(1);\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function _toAmount(\n        uint256 totalShares_,\n        uint256 totalAmount,\n        uint256 share,\n        bool roundUp\n    ) internal pure returns (uint256 amount) {\n        // To prevent reseting the ratio due to withdrawal of all shares, we start with\n        // 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which\n        // functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy\n        // due to 'gifting' or rebasing tokens. (Up to a certain degree)\n        totalAmount = totalAmount.add(1);\n        totalShares_ = totalShares_.add(1e8);\n\n        // Calculte the amount using te current amount to share ratio\n        amount = share.mul(totalShares_) / totalAmount;\n\n        // Default is to round down (Solidity), round up if required\n        if (roundUp && amount.mul(totalShares_) / totalAmount < share) {\n            amount = amount.add(1);\n        }\n    }\n\n    /// @dev Returns the total balance of `token` this contracts holds,\n    /// plus the total amount this contract thinks the strategy holds.\n    function _tokenBalanceOf(Asset memory asset) internal returns (uint256 amount) {\n        if (asset.strategy == IStrategy(0)) {\n            if (asset.standard == EIP20) {\n                return IERC20(asset.contractAddress).safeBalanceOf(address(this));\n            } else if (asset.standard == EIP1155) {\n                return IERC1155(asset.contractAddress).balanceOf(address(this), asset.tokenId);\n            }\n        } else {\n            return asset.strategy.currentBalance();\n        }\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return\n            interfaceID == 0x01ffc9a7 || // EIP-165\n            interfaceID == 0xd9b67a26 || // EIP-1155\n            interfaceID == 0x0e89341c; // EIP-1155 Metadata\n    }\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param assetId The id of the asset.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        uint256 assetId,\n        uint256 amount,\n        bool roundUp\n    ) external returns (uint256 share) {\n        share = _toShares(totalShares[assetId], _tokenBalanceOf(assets[assetId]), amount, roundUp);\n    }\n\n    /// @dev Helper function represent shares back into the `token` amount.\n    /// @param assetId The id of the asset.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        uint256 assetId,\n        uint256 share,\n        bool roundUp\n    ) external returns (uint256 amount) {\n        amount = _toAmount(totalShares[assetId], _tokenBalanceOf(assets[assetId]), share, roundUp);\n    }\n\n    function registerAsset(uint96 standard, address contractAddress, IStrategy strategy, uint256 tokenId) public returns (uint256 assetId) {\n        // Checks\n        require(tokenId == 0 || standard != EIP20, \"YieldBox: No tokenId for ERC20\");\n        require(strategy == IStrategy(0) || (standard == strategy.standard() && contractAddress == strategy.contractAddress() && tokenId == strategy.tokenId()), \"YieldBox: Strategy mismatch\");\n\n        // Effects\n        assetId = ids[standard][contractAddress][strategy][tokenId];\n        if (assetId == 0) {\n            assets.push(Asset(standard, contractAddress, strategy, tokenId));\n            assetId = assets.length;\n            ids[standard][contractAddress][strategy][tokenId] = assetId;\n        }\n    }\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param assetId The id of the asset.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount repesented in shares.\n    function deposit(\n        uint256 assetId,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {\n        // Checks\n        require(to != address(0), \"YieldBox: to not set\"); // To avoid a bad UI from burning funds\n\n        // Effects\n        Asset memory asset = assets[assetId];\n        uint256 totalAmount = _tokenBalanceOf(asset);\n\n        // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.\n        // Prevents getting shares for a token that will be deployed with CREATE2 in the future or as the contract creation is\n        // in the mempool\n        if (totalAmount == 0) {\n            if (asset.standard == EIP20) {\n                require(asset.contractAddress.isContract(), \"YieldBox: Not a token\");\n            }\n        }\n\n        if (share == 0) {\n            // value of the share may be lower than the amount due to rounding, that's ok\n            share = _toShares(totalShares[assetId], totalAmount, amount, false);\n        } else {\n            // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)\n            amount = _toAmount(totalShares[assetId], totalAmount, share, true);\n        }\n\n        shares[assetId][to] = shares[assetId][to].add(share);\n        totalShares[assetId] = totalShares[assetId].add(share);\n\n        // Interactions\n        if (asset.standard == EIP20) {\n            IERC20(asset.contractAddress).safeTransferFrom(from, asset.strategy == IStrategy(0) ? address(this) : address(asset.strategy), amount);\n        } else if (asset.standard == EIP1155) {\n            IERC1155(asset.contractAddress).safeTransferFrom(from, asset.strategy == IStrategy(0) ? address(this) : address(asset.strategy), asset.tokenId, amount, \"\");\n        }\n        emit TransferSingle(msg.sender, address(0), to, assetId, share);\n        amountOut = amount;\n        shareOut = share;\n    }\n\n    function depositETH(\n        uint256 assetId,\n        address to\n    ) public payable returns (uint256 amountOut, uint256 shareOut) {\n        // Checks\n        require(to != address(0), \"YieldBox: 'to' not set\"); // To avoid a bad UI from burning funds\n        Asset memory asset = assets[assetId];\n        require(asset.standard == EIP20 && IERC20(asset.contractAddress) == wethToken, \"YieldBox: not WETH\");\n\n        // Effects\n        uint256 amount = msg.value;\n        uint256 share = _toShares(totalShares[assetId], _tokenBalanceOf(asset), amount, false);\n\n        shares[assetId][to] = shares[assetId][to].add(share);\n        totalShares[assetId] = totalShares[assetId].add(share);\n\n        // Interactions\n        IWETH(address(wethToken)).deposit{value: amount}();\n        if (asset.strategy != IStrategy(0)) {\n            wethToken.safeTransfer(address(asset.strategy), amount);\n        }\n        emit TransferSingle(msg.sender, address(0), to, assetId, share);\n        amountOut = amount;\n        shareOut = share;\n    }\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param assetId The id of the asset.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        uint256 assetId,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {\n        // Checks\n        require(to != address(0), \"YieldBox: to not set\"); // To avoid a bad UI from burning funds\n\n        // Effects\n        Asset memory asset = assets[assetId];\n        uint256 totalAmount = _tokenBalanceOf(asset);\n        if (share == 0) {\n            // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)\n            share = _toShares(totalShares[assetId], totalAmount, amount, true);\n        } else {\n            // amount may be lower than the value of share due to rounding, that's ok\n            amount = _toAmount(totalShares[assetId], totalAmount, share, false);\n        }\n\n        shares[assetId][from] = shares[assetId][from].sub(share);\n        totalShares[assetId] = totalShares[assetId].sub(share);\n\n        // Interactions\n        if (asset.strategy == IStrategy(0)) {\n            if (asset.standard == EIP20) {\n                IERC20(asset.contractAddress).safeTransfer(to, amount);\n            } else if (asset.standard == EIP1155) {\n                IERC1155(asset.contractAddress).safeTransferFrom(address(this), to, asset.tokenId, amount, \"\");\n            }\n        } else {\n            asset.strategy.withdraw(amount, to);\n        }\n\n        emit TransferSingle(msg.sender, from, address(0), assetId, share);\n        amountOut = amount;\n        shareOut = share;\n    }\n\n    function withdrawETH(\n        uint256 assetId,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {\n        // Checks\n        require(to != address(0), \"YieldBox: to not set\"); // To avoid a bad UI from burning funds\n        Asset memory asset = assets[assetId];\n        require(asset.standard == EIP20 && IERC20(asset.contractAddress) == wethToken, \"YieldBox: not WETH\");\n\n        // Effects\n        uint256 totalAmount = _tokenBalanceOf(asset);\n        if (share == 0) {\n            // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)\n            share = _toShares(totalShares[assetId], totalAmount, amount, true);\n        } else {\n            // amount may be lower than the value of share due to rounding, that's ok\n            amount = _toAmount(totalShares[assetId], totalAmount, share, false);\n        }\n\n        shares[assetId][from] = shares[assetId][from].sub(share);\n        totalShares[assetId] = totalShares[assetId].sub(share);\n\n        // Interactions\n        if (asset.strategy == IStrategy(0)) {\n            IWETH(address(wethToken)).withdraw(amount);\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"YieldBox: ETH transfer failed\");\n        } else {\n            asset.strategy.withdrawETH(amount, to);\n        }\n\n        emit TransferSingle(msg.sender, from, address(0), assetId, share);\n        amountOut = amount;\n        shareOut = share;\n    }    \n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param assetId The id of the asset.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        uint256 assetId,\n        address from,\n        address to,\n        uint256 share\n    ) public allowed(from) {\n        // Checks\n        require(to != address(0), \"YieldBox: to not set\"); // To avoid a bad UI from burning funds\n\n        // Effects\n        shares[assetId][from] = shares[assetId][from].sub(share);\n        shares[assetId][to] = shares[assetId][to].add(share);\n\n        emit TransferSingle(msg.sender, from, to, assetId, share);\n    }\n\n    function batchTransfer(\n        address from,\n        address to,\n        uint256[] calldata assetIds_,\n        uint256[] calldata shares_\n    ) public allowed(from) {\n        // Checks\n        require(to != address(0), \"YieldBox: to not set\"); // To avoid a bad UI from burning funds\n\n        // Effects\n        uint256 len = assetIds_.length;\n        for (uint256 i = 0; i < len; i++) {\n            uint256 assetId = assetIds_[i];\n            uint256 share = shares_[i];\n            shares[assetId][from] = shares[assetId][from].sub(share);\n            shares[assetId][to] = shares[assetId][to].add(share);\n        }\n\n        emit TransferBatch(msg.sender, from, to, assetIds_, shares_);\n    }\n\n    /// @notice Transfer shares from a user account to multiple other ones.\n    /// @param assetId The id of the asset.\n    /// @param from which user to pull the tokens.\n    /// @param tos The receivers of the tokens.\n    /// @param share The amount of `token` in shares for each receiver in `tos`.\n    function transferMultiple(\n        uint256 assetId,\n        address from,\n        address[] calldata tos,\n        uint256[] calldata share\n    ) public allowed(from) {\n        // Checks\n        require(tos[0] != address(0), \"YieldBox: tos[0] not set\"); // To avoid a bad UI from burning funds\n\n        // Effects\n        uint256 totalAmount;\n        uint256 len = tos.length;\n        for (uint256 i = 0; i < len; i++) {\n            address to = tos[i];\n            uint256 share_ = share[i];\n            shares[assetId][to] = shares[assetId][to].add(share_);\n            totalAmount = totalAmount.add(share_);\n            emit TransferSingle(msg.sender, from, to, assetId, share_);\n        }\n        shares[assetId][from] = shares[assetId][from].sub(totalAmount);\n    }\n\n    /// The following safeTransfer functions are purely here to be EIP-1155 compliant. Using these in your protocol is NOT recommended as it opens\n    /// up many attack vectors, such as reentrancy issues and denial of service?\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 assetId,\n        uint256 share,\n        bytes calldata data\n    ) external {\n        transfer(assetId, from, to, share);\n\n        if (to.isContract()) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, assetId, share, data) ==\n                    bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")),\n                \"Wrong return value\"\n            );\n        }\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata assetIds_,\n        uint256[] calldata shares_,\n        bytes calldata data\n    ) external {\n        // Effects\n        batchTransfer(from, to, assetIds_, shares_);\n\n        if (to.isContract()) {\n            require(\n                IERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, assetIds_, shares_, data) ==\n                    bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")),\n                \"Wrong return value\"\n            );\n        }\n    }\n\n    function balanceOf(address owner, uint256 assetId) external view returns (uint256) {\n        return shares[assetId][owner];\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids_) external view returns (uint256[] memory balances) {\n        uint256 len = owners.length;\n        balances = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            balances[i] = shares[ids_[i]][owners[i]];\n        }\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        // Checks\n        require(operator != address(0), \"YieldBox: operator not set\"); // Important for security\n        require(masterContractOf[msg.sender] == address(0), \"YieldBox: user is clone\");\n\n        // Effects\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    // See https://eips.ethereum.org/EIPS/eip-191\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\n    bytes32 private constant APPROVAL_SIGNATURE_HASH =\n        keccak256(\"setApprovalForAllWithPermit(address user,address operator,bool approved,uint256 nonce)\");\n\n    /// @notice user nonces for masterContract approvals\n    mapping(address => uint256) public nonces;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    function setApprovalForAllWithPermit(\n        address user,\n        address operator,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        // Checks\n        require(operator != address(0), \"YieldBox: operator not set\"); // Important for security\n        require(masterContractOf[user] == address(0), \"YieldBox: user is clone\");\n\n        // Important for security - any address without masterContract has address(0) as masterContract\n        // So approving address(0) would approve every address, leading to full loss of funds\n        // Also, ecrecover returns address(0) on failure. So we check this:\n        require(user != address(0), \"YieldBox: User cannot be 0\");\n\n        bytes32 digest = _getDigest(keccak256(abi.encode(APPROVAL_SIGNATURE_HASH, user, operator, approved, nonces[user]++)));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == user, \"YieldBox: Invalid Signature\");\n\n        // Effects\n        isApprovedForAll[user][operator] = approved;\n        emit ApprovalForAll(user, operator, approved);\n    }\n\n    function uri(uint256 assetId) external view returns (string memory) {\n        // TODO: Support EIP1155\n        // TODO: Add strategy info\n        IERC20 token = IERC20(assets[assetId].contractAddress);\n        return\n                abi.encodePacked(\n                    '{\"name\": \"',\n                    token.safeName(),\n                    '\", \"symbol\": \"', // properties\n                    token.safeSymbol(),\n                    '\", \"decimals\": ',\n                    token.safeDecimals(),\n                    \"}\"\n                )\n                .encode();\n    }\n\n    // ERC1155 bloat we have to include to be able to receive ERC1155 tokens.\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external override returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external override returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n    }\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IStrategy {\n    /// Each strategy only works with a single asset. This shoudl help make implementations simpler and more readable.\n    /// To safe gas a proxy pattern (YieldBox factory) could be used to deploy the same strategy for multiple tokens.\n\n    /// It is recommended that strategies keep a small amount of funds uninvested (like 5%) to handle small withdrawals\n    /// and deposits without triggering costly investing/divesting logic.\n\n    /// #########################\n    /// ### Basic Information ###\n    /// #########################\n\n    /// Returns a name for this strategy\n    function name() external view returns (string memory name_);\n\n    /// Returns a description for this strategy\n    function description() external view returns (string memory description_);\n\n    /// #######################\n    /// ### Supported Token ###\n    /// #######################\n\n    /// Returns the standard that this strategy works with\n    function standard() external view returns (uint96 standard_);\n\n    /// Returns the contract address that this strategy works with\n    function contractAddress() external view returns (address contractAddress_);\n\n    /// Returns the tokenId that this strategy works with (for EIP1155)\n    /// This is always 0 for EIP20 tokens\n    function tokenId() external view returns (uint256 tokenId_);\n\n    /// ###########################\n    /// ### Balance Information ###\n    /// ###########################\n\n    /// Returns the total value the strategy holds (principle + gain) expressed in asset token amount.\n    /// This should be cheap in gas to retrieve. Can return a bit less than the actual, but shouldn't return more.\n    /// The gas cost of this function will be paid on any deposit or withdrawal onto and out of the YieldBox\n    /// that uses this strategy. Also, anytime a protocol converts between shares and amount, this gets called.\n    function currentBalance() external returns (uint256 amount);\n\n    /// Returns the maximum amount that can be withdrawn\n    function withdrawable() external view returns (uint256 amount);\n\n    /// Returns the maximum amount that can be withdrawn for a low gas fee\n    /// When more than this amount is withdrawn it will trigger divesting from the actual strategy\n    /// which will incur higher gas costs\n    function cheapWithdrawable() external view returns (uint256 amount);\n\n    /// ##########################\n    /// ### YieldBox Functions ###\n    /// ##########################\n\n    /// Is called by YieldBox to signal funds have been added, the strategy may choose to act on this\n    /// When a large enough deposit is made, this should trigger the strategy to invest into the actual\n    /// strategy. This function should normally NOT be used to invest on each call as that would be costly\n    /// for small deposits.\n    /// Only accept this call from the YieldBox\n    function deposited(uint256 amount) external;\n\n    /// Is called by the YieldBox to ask the strategy to withdraw to the user\n    /// When a strategy keeps a little reserve for cheap withdrawals and the requested withdrawal goes over this amount,\n    /// the strategy should divest enough from the strategy to complete the withdrawal and rebalance the reserve.\n    /// Only accept this call from the YieldBox\n    function withdraw(uint256 amount, address to) external;\n\n    /// Is called by the YieldBox to ask the strategy to withdraw ETH to the user\n    /// Must be implemented for strategies handling WETH\n    /// If the strategy doesn't handle WETH it will never be called\n    /// When a strategy keeps a little reserve for cheap withdrawals and the requested withdrawal goes over this amount,\n    /// the strategy should divest enough from the strategy to complete the withdrawal and rebalance the reserve.\n    /// Only accept this call from the YieldBox\n    function withdrawETH(uint256 amount, address to) external;\n}\n"
    },
    "contracts/interfaces/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IERC1155TokenReceiver {\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return \"\";\n\n        // load the table into memory\n        string memory table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n                case 1 {\n                    mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n                }\n                case 2 {\n                    mstore(sub(resultPtr, 1), shl(248, 0x3d))\n                }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/// @notice A library for performing overflow-/underflow-safe math,\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\nlibrary BoringMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\n    }\n\n    function to128(uint256 a) internal pure returns (uint128 c) {\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\n        c = uint128(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64 c) {\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\n        c = uint64(a);\n    }\n\n    function to32(uint256 a) internal pure returns (uint32 c) {\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\n        c = uint32(a);\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\nlibrary BoringMath64 {\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\nlibrary BoringMath32 {\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n//SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n// solhint-disable no-inline-assembly\n\nlibrary BoringAddress {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../interfaces/IERC20.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while (i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @param to The address of the user to check.\n    /// @return amount The token amount.\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\n        require(success && data.length >= 32, \"BoringERC20: BalanceOf failed\");\n        amount = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/Domain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on code and smartness by Ross Campbell and Keno\n// Uses immutable to store the domain separator to reduce gas usage\n// If the chain id changes due to a fork, the forked chain will calculate on the fly.\npragma solidity 0.6.12;\n\n// solhint-disable no-inline-assembly\n\ncontract Domain {\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n    // See https://eips.ethereum.org/EIPS/eip-191\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\n\n    // solhint-disable var-name-mixedcase\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;\n\n    /// @dev Calculate the DOMAIN_SEPARATOR\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, chainId, address(this)));\n    }\n\n    constructor() public {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR\n    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\n    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\n    // solhint-disable-next-line func-name-mixedcase\n    function _domainSeparator() internal view returns (bytes32) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n    }\n\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n        digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/BoringBatchable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\n// WARNING!!!\n// Combining BoringBatchable with msg.value can cause double spending issues\n// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/\n\nimport \"./interfaces/IERC20.sol\";\n\ncontract BaseBoringBatchable {\n    /// @dev Helper function to extract a useful revert message from a failed call.\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param calls An array of inputs for each call.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n    // C3: The length of the loop is fully under user control, so can't be exploited\n    // C7: Delegatecall is only used on the same contract, so it's safe\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable {\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            if (!success && revertOnFail) {\n                revert(_getRevertMsg(result));\n            }\n        }\n    }\n}\n\ncontract BoringBatchable is BaseBoringBatchable {\n    /// @notice Call wrapper that performs `ERC20.permit` on `token`.\n    /// Lookup `IERC20.permit`.\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\n    function permitToken(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        token.permit(from, to, amount, deadline, v, r, s);\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/BoringFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./interfaces/IMasterContract.sol\";\n\n// solhint-disable no-inline-assembly\n\ncontract BoringFactory {\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\n\n    /// @notice Mapping from clone contracts to their masterContract.\n    mapping(address => address) public masterContractOf;\n\n    /// @notice Deploys a given master Contract as a clone.\n    /// Any ETH transferred with this call is forwarded to the new clone.\n    /// Emits `LogDeploy`.\n    /// @param masterContract The address of the contract to clone.\n    /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`.\n    /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt.\n    /// @return cloneAddress Address of the created clone contract.\n    function deploy(\n        address masterContract,\n        bytes calldata data,\n        bool useCreate2\n    ) public payable returns (address cloneAddress) {\n        require(masterContract != address(0), \"BoringFactory: No masterContract\");\n        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address\n\n        if (useCreate2) {\n            // each masterContract has different code already. So clones are distinguished by their data only.\n            bytes32 salt = keccak256(data);\n\n            // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\n            assembly {\n                let clone := mload(0x40)\n                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n                mstore(add(clone, 0x14), targetBytes)\n                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n                cloneAddress := create2(0, clone, 0x37, salt)\n            }\n        } else {\n            assembly {\n                let clone := mload(0x40)\n                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n                mstore(add(clone, 0x14), targetBytes)\n                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n                cloneAddress := create(0, clone, 0x37)\n            }\n        }\n        masterContractOf[cloneAddress] = masterContract;\n\n        IMasterContract(cloneAddress).init{value: msg.value}(data);\n\n        emit LogDeploy(masterContract, data, cloneAddress);\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IMasterContract {\n    /// @notice Init function that gets called from `BoringFactory.deploy`.\n    /// Also kown as the constructor for cloned contracts.\n    /// Any ETH send to `BoringFactory.deploy` ends up here.\n    /// @param data Can be abi encoded arguments or anything else.\n    function init(bytes calldata data) external payable;\n}\n"
    },
    "contracts/samples/salary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"../YieldBox.sol\";\n\n// solhint-disable not-rely-on-time\n\n// IDEA: Make changes to salaries, funder or recipient\n// IDEA: Enable partial withdrawals\n\ncontract Salary is BoringBatchable {\n    using BoringMath for uint256;\n\n    YieldBox public yieldBox;\n\n    event LogCreate(\n        address indexed funder,\n        address indexed recipient,\n        uint256 indexed assetId,\n        uint32 cliffTimestamp,\n        uint32 endTimestamp,\n        uint32 cliffPercent,\n        uint128 totalShares,\n        uint256 salaryId\n    );\n    event LogWithdraw(uint256 indexed salaryId, address indexed to, uint256 shares);\n    event LogCancel(uint256 indexed salaryId, address indexed to, uint256 shares);\n\n    constructor(YieldBox _yieldBox) public {\n        yieldBox = _yieldBox;\n    }\n\n    // Included to be able to approve YieldBox and create in the same transaction (using batch)\n    function setYieldBoxApproval(\n        address user,\n        address operator,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        yieldBox.setApprovalForAllWithPermit(user, operator, approved, v, r, s);\n    }\n\n    ///     now                      cliffTimestamp\n    ///      |                             |     endTimestamp\n    ///      V                             V          |\n    ///      -------------------------------          |\n    ///      |        ^             ^      |          V\n    ///      |        |       cliffPercent |\n    ///      |        |             V      |\n    ///      |        |             -----> |\n    ///      |        |                      \\\n    ///      |   totalShares                   \\\n    ///      |        |                          \\\n    ///      |        |                            \\\n    ///      |        V                              \\\n    ///      -----------------------------------------\n    struct UserSalary {\n        // The recipient of the salary\n        address recipient;\n        // The ERC20 token\n        uint256 assetId;\n        // The amount of shares that the recipient has already withdrawn\n        uint256 withdrawnShares;\n        // The timestamp of the cliff (also the start of the slope)\n        uint32 cliffTimestamp;\n        // The timestamp of the end of vesting (the end of the slope)\n        uint32 endTimestamp;\n        // The cliff payout in percent of the shares, 1e18 = 100%\n        uint64 cliffPercent;\n        // The total payout in shares\n        uint128 shares;\n    }\n\n    /// Array of all salaries managed by the contract\n    UserSalary[] public salaries;\n    /// The funder of each salary, separated out for gas optimization\n    address[] public funder;\n\n    uint8 private constant MODE_YIELDBOX = 0; // Use YieldBox balance\n    uint8 private constant MODE_ERC20 = 2; // Use ERC20 tokens in the users wallet (transferFrom with approval)\n\n    /// Create a salary\n    function create(\n        address recipient,\n        uint256 assetId,\n        uint32 cliffTimestamp,\n        uint32 endTimestamp,\n        uint32 cliffPercent,\n        uint8 mode,\n        uint128 amount\n    ) public returns (uint256 salaryId, uint256 shares) {\n        // Check that the end if after or equal to the cliff\n        // If they are equal, all shares become payable at once, use this for a fixed term lockup\n        require(cliffTimestamp <= endTimestamp, \"Salary: cliff > end\");\n        // You cannot have a cliff greater than 100%, important check, without the contract will lose funds\n        require(cliffPercent <= 1e18, \"Salary: cliff too large\");\n\n        if (mode == MODE_YIELDBOX) {\n            // Fund this salary using the funder's YieldBox balance. Convert the amoutn to shares, then transfer the shares\n            shares = yieldBox.toShare(assetId, amount, false);\n            yieldBox.transfer(assetId, msg.sender, address(this), shares);\n        } else {\n            // Fund this salary with ERC20 tokens\n            // This is a potential reentrancy target, funds in this contract could be higher than the total of salaries during this call\n            // Since this contract doesn't have a skim function, this is ok\n            (, shares) = yieldBox.deposit(assetId, msg.sender, address(this), amount, 0);\n        }\n\n        salaryId = salaries.length;\n        UserSalary memory salary;\n        salary.recipient = recipient;\n        salary.assetId = assetId;\n        salary.cliffTimestamp = cliffTimestamp;\n        salary.endTimestamp = endTimestamp;\n        salary.cliffPercent = cliffPercent;\n        salary.shares = shares.to128();\n        salaries.push(salary);\n        funder.push(msg.sender);\n\n        emit LogCreate(msg.sender, recipient, assetId, cliffTimestamp, endTimestamp, cliffPercent, shares.to128(), salaryId);\n    }\n\n    function _available(UserSalary memory salary) internal view returns (uint256 shares) {\n        if (block.timestamp < salary.cliffTimestamp) {\n            // Before the cliff, none is available\n            shares = 0;\n        } else if (block.timestamp >= salary.endTimestamp) {\n            // After the end, all is available\n            shares = salary.shares;\n        } else {\n            // In between, cliff is available, rest according to slope\n\n            // Time that has passed since the cliff\n            uint256 timeSinceCliff = block.timestamp.sub(salary.cliffTimestamp);\n            // Total time period of the slope\n            uint256 timeSlope = uint256(salary.endTimestamp).sub(salary.cliffTimestamp);\n            uint256 payablePercent = salary.cliffPercent;\n            if (timeSinceCliff > 0) {\n                // The percentage paid out during the slope\n                uint256 slopePercent = uint256(1e18).sub(uint256(salary.cliffPercent));\n                // The percentage payable on the slope added to the cliff percentage\n                payablePercent = payablePercent.add(slopePercent.mul(timeSinceCliff) / timeSlope);\n            }\n            // The share payable\n            shares = uint256(salary.shares).mul(payablePercent) / 1e18;\n        }\n\n        // Remove any shares already wiythdrawn, if negative, return 0\n        if (shares > salary.withdrawnShares) {\n            shares = shares.sub(salary.withdrawnShares);\n        } else {\n            shares = 0;\n        }\n    }\n\n    // Get the number of shares currently available for withdrawal by salaryId\n    function available(uint256 salaryId) public view returns (uint256 shares) {\n        shares = _available(salaries[salaryId]);\n    }\n\n    // Withdraw the maximum amount possible for a salaryId\n    function withdraw(\n        uint256 salaryId,\n        address to,\n        bool toYieldBox\n    ) public {\n        UserSalary memory salary = salaries[salaryId];\n        // Only pay out to the recipient\n        require(salary.recipient == msg.sender, \"Salary: not recipient\");\n\n        uint256 pendingShares = _available(salary);\n        salaries[salaryId].withdrawnShares = salary.withdrawnShares.add(pendingShares);\n        if (toYieldBox) {\n            yieldBox.transfer(salary.assetId, address(this), to, pendingShares);\n        } else {\n            yieldBox.withdraw(salary.assetId, address(this), to, 0, pendingShares);\n        }\n        emit LogWithdraw(salaryId, to, pendingShares);\n    }\n\n    // Modifier for functions only allowed by the funder\n    modifier onlyFunder(uint256 salaryId) {\n        require(funder[salaryId] == msg.sender, \"Salary: not funder\");\n        _;\n    }\n\n    // Cancel a salary, can only be done by the funder\n    function cancel(\n        uint256 salaryId,\n        address to,\n        bool toYieldBox\n    ) public onlyFunder(salaryId) {\n        uint256 sharesLeft = uint256(salaries[salaryId].shares).sub(salaries[salaryId].withdrawnShares);\n        if (toYieldBox) {\n            yieldBox.transfer(salaries[salaryId].assetId, address(this), to, sharesLeft);\n        } else {\n            yieldBox.withdraw(salaries[salaryId].assetId, address(this), to, 0, sharesLeft);\n        }\n        emit LogCancel(salaryId, to, sharesLeft);\n    }\n}\n"
    },
    "contracts/samples/helloworld.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../YieldBox.sol\";\n\n// An example a contract that stores tokens in the YieldBox.\n// A single contract that users can approve for the YieldBox, hence the registerProtocol call.\n// PS. This isn't good code, just kept it simple to illustrate usage.\ncontract HelloWorld {\n    uint96 private constant EIP20 = 1;\n\n    YieldBox public immutable yieldBox;\n    IStrategy public immutable strategy;\n    uint256 public immutable assetId;\n\n    constructor(YieldBox _yieldBox, IERC20 token, IStrategy _strategy) public {\n        yieldBox = _yieldBox;\n        strategy = _strategy;\n        assetId = _yieldBox.registerAsset(EIP20, address(token), _strategy, 0);\n    }\n\n    mapping(address => uint256) public yieldBoxShares;\n\n    // Deposits an amount of token into the YieldBox. YieldBox shares are given to the HelloWorld contract and\n    // assigned to the user in yieldBoxShares.\n    // Don't deposit twice, you'll lose the first deposit ;)\n    function deposit(uint256 amount) public {\n        (, yieldBoxShares[msg.sender]) = yieldBox.deposit(assetId, msg.sender, address(this), amount, 0);\n    }\n\n    // This will return the current value in amount of the YieldBox shares.\n    // Through flash loans and maybe a strategy, the value can go up over time.\n    function balance() public returns (uint256 amount) {\n        return yieldBox.toAmount(assetId, yieldBoxShares[msg.sender], false);\n    }\n\n    // Withdraw all shares from the YieldBox and receive the token.\n    function withdraw() public {\n        yieldBox.withdraw(assetId, address(this), msg.sender, 0, yieldBoxShares[msg.sender]);\n    }\n}\n"
    },
    "contracts/mocks/MasterContractMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"../YieldBox.sol\";\n\ncontract MasterContractMock is IMasterContract {\n    YieldBox public immutable yieldBox;\n\n    constructor(YieldBox _yieldBox) public {\n        yieldBox = _yieldBox;\n    }\n\n    function deposit(uint256 id, uint256 amount) public {\n        yieldBox.deposit(id, msg.sender, address(this), 0, amount);\n    }\n\n    function init(bytes calldata) external payable override {\n        return;\n    }\n}\n"
    },
    "contracts/mocks/MaliciousMasterContractMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"../YieldBox.sol\";\n\ncontract MaliciousMasterContractMock is IMasterContract {\n    function init(bytes calldata) external payable override {\n        return;\n    }\n\n    function attack(YieldBox yieldBox) public {\n        yieldBox.setApprovalForAll(address(this), true);\n    }\n}\n"
    },
    "contracts/strategies/SushiStakingStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"../interfaces/IStrategy.sol\";\n\ninterface ISushiBar is IERC20 {\n    function enter(uint256 amount) external;\n    function leave(uint256 share) external;\n}\n\ncontract SushiStakingStrategy is IStrategy {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n    string public constant override name = \"SushiStaking\";\n    string public constant override description = \"Stakes SUSHI into the SushiBar for xSushi\";\n\n    uint96 public constant override standard = 0; // ERC20;\n    address public constant override contractAddress = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\n    uint256 public constant override tokenId = 0;\n\n    IERC20 private constant sushi = IERC20(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2);\n    ISushiBar private constant sushiBar = ISushiBar(0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272);\n\n    struct BalanceCache {\n        uint64 last;\n        uint192 balance;\n    }\n\n    BalanceCache cache;\n\n    /// Returns the total value the strategy holds (principle + gain) expressed in asset token amount.\n    /// This should be cheap in gas to retrieve. Can return a bit less than the actual, but shouldn't return more.\n    /// The gas cost of this function will be paid on any deposit or withdrawal onto and out of the YieldBox\n    /// that uses this strategy. Also, anytime a protocol converts between shares and amount, this gets called.\n    function currentBalance() public override returns (uint256 amount) {\n        // Only update if the last call is 240 blocks ago (about an hour)\n        if (block.number - cache.last > 240) {\n            cache = BalanceCache(\n                uint64(block.number),\n                uint192(_currentBalance())\n            );\n        }\n        return cache.balance;\n    }\n\n    function _currentBalance() internal view returns (uint256 amount) {\n        return sushi.balanceOf(address(this)).add(\n            sushi.balanceOf(address(sushiBar)).mul(sushiBar.balanceOf(address(this))) / sushiBar.totalSupply()\n        );\n    }\n\n    /// Returns the maximum amount that can be withdrawn\n    function withdrawable() external view override returns (uint256 amount) {\n        return _currentBalance();\n    }\n\n    /// Returns the maximum amount that can be withdrawn for a low gas fee\n    /// When more than this amount is withdrawn it will trigger divesting from the actual strategy\n    /// which will incur higher gas costs\n    function cheapWithdrawable() external view override returns (uint256 amount) {\n        return sushi.balanceOf(address(this));\n    }\n\n    uint256 MAX_RESERVE_PERCENT = 10e18;\n    uint256 TARGET_RESERVE_PERCENT = 5e18;\n\n    /// Is called by YieldBox to signal funds have been added, the strategy may choose to act on this\n    /// When a large enough deposit is made, this should trigger the strategy to invest into the actual\n    /// strategy. This function should normally NOT be used to invest on each call as that would be costly\n    /// for small deposits.\n    /// Only accept this call from the YieldBox\n    function deposited(uint256 amount) external override {\n        // Update cached balance with the new added amount\n        cache.balance += uint192(amount);\n        // Get the size of the reserve in % (1e18 based)\n        uint256 reservePercent = sushi.balanceOf(address(this)).mul(100e18) / cache.balance;\n\n        // Check if the reserve is too large, if so invest it\n        if (reservePercent > MAX_RESERVE_PERCENT) {\n            sushiBar.enter(\n                uint256(cache.balance).mul(reservePercent.sub(TARGET_RESERVE_PERCENT)) / 100e18\n            );\n        }\n    }\n\n    /// Is called by the YieldBox to ask the strategy to withdraw to the user\n    /// When a strategy keeps a little reserve for cheap withdrawals and the requested withdrawal goes over this amount,\n    /// the strategy should divest enough from the strategy to complete the withdrawal and rebalance the reserve.\n    /// Only accept this call from the YieldBox\n    function withdraw(uint256 amount, address to) external override {\n        cache.balance = cache.balance > amount ? uint192(cache.balance - amount) : 0;\n\n        uint256 reserve = sushi.balanceOf(address(this));\n        if (reserve < amount) {\n            uint256 shares = sushiBar.balanceOf(address(this));\n            if (cache.balance == 0) {\n                // Withdraw all from SushiBar\n                sushiBar.leave(shares);\n            } else {\n                uint256 totalShares = sushiBar.totalSupply();\n                uint256 totalSushi = sushi.balanceOf(address(sushiBar));\n\n                // The amount of Sushi that should invested after withdrawal\n                uint256 targetSushi = uint256(cache.balance).mul(100e18 - TARGET_RESERVE_PERCENT) / 100e18;\n                // The amount of shares (xSushi) that should be invested after withdrawal\n                uint256 targetShares = targetSushi.mul(totalShares) / totalSushi;\n\n                sushiBar.leave(shares.sub(targetShares));\n            }\n        }\n\n        sushi.safeTransfer(to, amount);\n    }\n\n    /// Is called by the YieldBox to ask the strategy to withdraw ETH to the user\n    /// Must be implemented for strategies handling WETH\n    /// If the strategy doesn't handle WETH it will never be called\n    /// When a strategy keeps a little reserve for cheap withdrawals and the requested withdrawal goes over this amount,\n    /// the strategy should divest enough from the strategy to complete the withdrawal and rebalance the reserve.\n    /// Only accept this call from the YieldBox\n    function withdrawETH(uint256 amount, address to) external override {\n        // Not implemented, not applicable    \n    }\n}\n"
    },
    "contracts/mocks/SushiBarMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\n\n// solhint-disable const-name-snakecase\n\n// SushiBar is the coolest bar in town. You come in with some Sushi, and leave with more! The longer you stay, the more Sushi you get.\n// This contract handles swapping to and from xSushi, SushiSwap's staking token.\ncontract SushiBarMock is ERC20 {\n    using BoringMath for uint256;\n    ERC20 public sushi;\n    uint256 public override totalSupply;\n    string public constant name = \"SushiBar\";\n    string public constant symbol = \"xSushi\";\n\n    // Define the Sushi token contract\n    constructor(ERC20 _sushi) public {\n        sushi = _sushi;\n    }\n\n    // Enter the bar. Pay some SUSHIs. Earn some shares.\n    // Locks Sushi and mints xSushi\n    function enter(uint256 _amount) public {\n        // Gets the amount of Sushi locked in the contract\n        uint256 totalSushi = sushi.balanceOf(address(this));\n        // Gets the amount of xSushi in existence\n        uint256 totalShares = totalSupply;\n        // If no xSushi exists, mint it 1:1 to the amount put in\n        if (totalShares == 0 || totalSushi == 0) {\n            _mint(msg.sender, _amount);\n        }\n        // Calculate and mint the amount of xSushi the Sushi is worth. The ratio will change overtime,\n        // as xSushi is burned/minted and Sushi deposited + gained from fees / withdrawn.\n        else {\n            uint256 what = _amount.mul(totalShares) / totalSushi;\n            _mint(msg.sender, what);\n        }\n        // Lock the Sushi in the contract\n        sushi.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Leave the bar. Claim back your SUSHIs.\n    // Unclocks the staked + gained Sushi and burns xSushi\n    function leave(uint256 _share) public {\n        // Gets the amount of xSushi in existence\n        uint256 totalShares = totalSupply;\n        // Calculates the amount of Sushi the xSushi is worth\n        uint256 what = _share.mul(sushi.balanceOf(address(this))) / totalShares;\n        _burn(msg.sender, _share);\n        sushi.transfer(msg.sender, what);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        totalSupply = totalSupply.add(amount);\n        balanceOf[account] = balanceOf[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        balanceOf[account] = balanceOf[account].sub(amount);\n        totalSupply = totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./interfaces/IERC20.sol\";\nimport \"./Domain.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable not-rely-on-time\n\n// Data part taken out for building of contracts that receive delegate calls\ncontract ERC20Data {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n}\n\nabstract contract ERC20 is IERC20, Domain {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public override balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param amount of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 amount) public returns (bool) {\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n        if (amount != 0 || msg.sender == to) {\n            uint256 srcBalance = balanceOf[msg.sender];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n            if (msg.sender != to) {\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param amount The token amount to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        // If `amount` is 0, or `from` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[from];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n\n            if (from != to) {\n                uint256 spenderAllowance = allowance[from][msg.sender];\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n                if (spenderAllowance != type(uint256).max) {\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n                }\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n    /// @param owner_ Address of the owner.\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n    /// @param value The maximum collective amount that `spender` can draw.\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\n        require(block.timestamp < deadline, \"ERC20: Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n                owner_,\n            \"ERC20: Invalid Signature\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n}\n\ncontract ERC20WithSupply is IERC20, ERC20 {\n    uint256 public override totalSupply;\n\n    function _mint(address user, uint256 amount) internal {\n        uint256 newTotalSupply = totalSupply + amount;\n        require(newTotalSupply >= totalSupply, \"Mint overflow\");\n        totalSupply = newTotalSupply;\n        balanceOf[user] += amount;\n        emit Transfer(address(0), user, amount);\n    }\n\n    function _burn(address user, uint256 amount) internal {\n        require(balanceOf[user] >= amount, \"Burn too much\");\n        totalSupply -= amount;\n        balanceOf[user] -= amount;\n        emit Transfer(user, address(0), amount);\n    }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    uint256 public override totalSupply;\n\n    constructor(uint256 _initialAmount) public {\n        // Give the creator all initial tokens\n        balanceOf[msg.sender] = _initialAmount;\n        // Update total supply\n        totalSupply = _initialAmount;\n    }\n}\n"
    },
    "contracts/mocks/ExternalFunctionMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\n\ncontract ExternalFunctionMock {\n    using BoringMath for uint256;\n\n    event Result(uint256 output);\n\n    function sum(uint256 a, uint256 b) external returns (uint256 c) {\n        c = a.add(b);\n        emit Result(c);\n    }\n}\n"
    },
    "contracts/mocks/BoringBoxMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"../YieldBox.sol\";\n\ncontract YieldBoxMock is YieldBox {\n    constructor(IERC20 weth) public YieldBox(weth) {\n        return;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}